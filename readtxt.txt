v1.0
v1.1
v1.2
****dev1*****
v1.3
v1.4
v1.5*版本回溯*
v1.6*撤销修改*
-------------------------------------------------
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作.
场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。
-------------------------------------------------
v1.7*添加demo.html文件 *
v1.8*删除文件*
---------------------------------
命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容.
git checkout -- <file>
---------------------------------
v1.9*因为之前的push或clone是用https不是ssh,所以每次push都要输入账号和密码，所以解决方法：git config --global credential.helper store
<<<<<<< HEAD
要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；

关联后，使用命令git push -u origin master第一次推送master分支的所有内容;
---------------------------------
v2.0*之前v1.*版本先有本地库后有远程库，从这里开始反过来
git clone 远程库地址 远程库分支 到本地分支名 
---------------------------------
v2.1*git pull=git fetch  + git merge*
git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。
而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge
，这样可能会产生冲突，需要手动解决。
*git fetch <远程主机名> <分支名>//将远程主机（分支)的更新全部取回本地
取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，
我们可以在本地通过它查看刚取回的更新信息：git log -p FETCH_HEAD
*git pull <远程主机名> <远程分支名>：<本地分支名>
*git push <远程主机名> <本地分支名>:<远程分支名> //可有参数 -u
git pull 可理解为：
git fetch origin master //从远程主机的master分支拉取最新内容
git merge FETCH_HEAD // 将拉取下来的最新内容合并到当前所在的分支中
git diff FETCH_HEAD //将拉取下来的内容与当前分支比较
------------------------------------------------------------------
v2.2*dev2-clone**分支管理*
git branch //查看本地所有分支

git checkout -b <branchname> //创建新分支并切换到该分支 

git branch -r //查看远程所有分支

git branch -a //查看本地和远程的所有分支

v2.3git branch <branchname> //新建分支

git branch -d <branchname> //删除本地分支

git branch -d -r <branchname> //删除远程分支，删除后还需推送到服务器
git push origin:<branchname>  //删除后推送至服务器

git branch -m <oldbranch> <newbranch> //重命名本地分支
<<<<<<< HEAD
---------------------------------------------------------------------
v2.3*解决冲突*
这是一句话
=======
-------------------------------------------------------------------
v2.3*解决冲突*
这是一句话
>>>>>>> dev2-clone_branch1
解析：
上面九行是dev2-clone和dev2-clone_branch1两个不同分支在commit操作之后，git merge发生合并冲突，标出的不同(用git diff或git status也可查看)；
git merge后(若有冲突，两个分支进入一个状态)修改冲突部分，进行add和commit操作完成合并。
-------------------------------------------------------------------
v2.4*删除远程分支*
*git branch -d -r <branchname>或git push origin --delete <branchname>
=======
>>>>>>> b97ef32b5ca820b89ec24bafcae88350d6b9abf6
----------------------------------------------------------
v2.5*git merge --no-ff*
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并
-----------------------------------------------------------
v2.6*git stash*
使用场景：当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交。stash的作用就可以把当前的工作现场储存起来，待恢复现场后继续工作
git stash list//可查看git stash储存起来的工作现场；
恢复工作现场有两个方法：
一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
另一种方式是用git stash pop，恢复的同时把stash内容也删了。
当有多个git stash时，先用git stash list查看，然后恢复指定的stash,可用git stash apply stash@{0}
------------------------------------------------------------
